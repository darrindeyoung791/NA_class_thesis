# 高效插值算法在实时图形渲染中的性能对比：从Lagrange到样条的实现与优化(Preview)

**摘要**：本文系统分析了传统插值算法（如Lagrange插值、三次样条插值、Catmull-Rom样条）与基于深度学习的超分辨率技术（如DLSS、RIFE）在实时图形渲染中的性能与精度特性。通过理论推导与实验验证，探讨了不同插值方法的数学原理、计算复杂度及其在动态场景中的适用性。研究结果表明，样条插值在速度与精度的平衡上优于Lagrange插值，而AI驱动的帧生成技术通过光流分析与并行计算，进一步突破了传统插值算法的性能瓶颈。



**关键词**：实时图形渲染 插值算法 Lagrange插值 样条插值 性能对比 帧插值 实时性 优化

---

## 1. 引言

随着计算机图形学和视频处理技术的飞速发展，实时图形渲染和视频处理的需求日益增长。以游戏行业为例，若希望保证玩家的基本游戏体验，则需在消费级个人PC和游戏主机上达到至少1080P分辨率+60Hz刷新率的性能表现，即每16.67毫秒需要完成一帧2073600个像素画面的渲染。现今许多游戏引入了各项高级技术，例如全局光线追踪（Global Illumination Ray Tracing）和基于物理的渲染（Physically Based Rendering, PBR）等技术，在不采取任何优化措施的情况下很难达到这一目标。

一个解决思路是先以低帧率低分辨率渲染帧，随后使用相关技术补全出不存在的中间帧、提升分辨率，实现帧数和清晰度的提升。现代技术，如NVIDIA的DLSS（Deep Learning Super Sampling）和AMD的FSR（FidelityFX Super Resolution），已经能够通过深度学习和人工智能技术实现高效的帧插值和超分辨率处理。这些技术分析连续帧之间的运动信息，结合先进的插值算法，实现了亚像素级的运动补偿和细节增强。不仅提升了图像和视频的视觉质量，还显著提高了渲染效率，使得在消费级个人PC上实现高分辨率和高帧率的实时渲染成为可能。

![图1 插值与超分辨率示意图](https://github.com/darrindeyoung791/NA_class_thesis/blob/master/res/img/Picture1.png?raw=true)

本文将首先介绍插值算法的基础知识，包括传统的Lagrange插值、样条插值（如三次样条和Catmull-Rom样条）等。随后我们将探讨这些插值算法如何应用于平面二维像素的画面插中间值，并通过简单的示例和伪代码来说明其实现过程。



## 2. 插值算法基础与性能分析

### 2.1 插值算法的基本概念

插值算法的基本思想是通过已知的数据点构建一个函数，然后利用这个函数来预测未知的数据点。不同的插值算法在精度、计算复杂度和适用场景上有所不同。常见的插值算法包括Lagrange插值、样条插值。在图形渲染中常使用基于深度学习的插值方法。

#### 2.1.1 Lagrange插值

Lagrange插值通过构造基函数

$L_i(x) = \prod_{j \neq i} \frac{x - x_j}{x_i - x_j}$，

将多项式表示为

$P(x) = \sum_{i=0}^n y_i L_i(x)$。

其时间复杂度为$O(n^2)$，易受Runge现象影响，导致高阶插值在边界区域振荡剧烈。



#### 2.1.2 样条插值

样条插值通过分段多项式函数实现对已知数据点的拟合。与Lagrange插值相比，样条插值能够有效避免高阶多项式带来的Runge现象，同时保持较好的数值稳定性。常用的样条插值方法包括：

##### 三次样条插值

三次样条插值是一种在每个子区间内使用三次多项式的插值方法。对于区间$[x_i, x_{i+1}]$，插值函数的形式为：
$$
S_i(x) = a_i + b_i(x - x_i) + c_i(x - x_i)^2 + d_i(x - x_i)^3
$$
为了确保插值函数的连续性和平滑性，需要满足以下条件：
1. 插值条件：$S_i(x_i) = y_i$
2. 一阶导数连续：$S_i'(x_{i+1}) = S_{i+1}'(x_{i+1})$
3. 二阶导数连续：$S_i''(x_{i+1}) = S_{i+1}''(x_{i+1})$

##### Catmull-Rom样条

Catmull-Rom样条是一种具有局部控制性好、计算效率高的插值方法。其插值公式为：
$$
P(t) = 0.5 \cdot [
    (-t^3 + 2t^2 - t)P_0 +
    (3t^3 - 5t^2 + 2)P_1 +
    (-3t^3 + 4t^2 + t)P_2 +
    (t^3 - t^2)P_3
]
$$
Catmull-Rom样条常用于动画路径生成和帧间插值，能够生成平滑且具有局部控制性的曲线。

##### B样条

B样条是一种具有局部控制性好、数值稳定性好的插值方法。其基函数采用递归定义：
$$
N_{i,1}(t) = \begin{cases}
1 & t_i \leq t < t_{i+1} \\
0 & \text{otherwise}
\end{cases}
$$
$$
N_{i,k}(t) = \frac{t - t_i}{t_{i+k-1} - t_i}N_{i,k-1}(t) + \frac{t_{i+k} - t}{t_{i+k} - t_{i+1}}N_{i+1,k-1}(t)
$$
B样条的基函数具有局部控制性，即每个基函数只在有限的区间内非零，这使得B样条在进行局部调整时不会影响整个曲线的形状。此外，B样条的数值稳定性好，能够有效地避免数值计算中的舍入误差。因此，B样条在计算机辅助设计、计算机图形学等领域得到了广泛的应用。

在实时图形渲染中，样条插值因其良好的光滑性和可控性而被广泛应用于路径生成、动画过渡和图像重建等场景。特别是在高帧率渲染中，Catmull-Rom样条因其计算效率高且能保持合理的视觉连续性，成为中间帧生成的重要工具。

### 2.2 插值算法在二维画面中的应用

在计算机图形学和视频处理中，插值算法用于生成已知数据点之间的未知数据点。例如，在视频帧插值中，插值算法可以用来生成两个已知帧之间的中间帧，从而提升视频的帧率。在图像超分辨率中，插值算法可以用来生成高分辨率图像中的像素值，从而提升图像的视觉质量。

课堂上所学的普通插值一般针对多项式函数等而言。对于二维图像的插值，本研究使用双变量插值方法，对图像的行与列进行插值。为确保运算简单，我们只讨论小分辨率范围下的单色图片。在程序代码中可以使用二维数组存放0和1来表示。

#### 双变量拉格朗日插值

双变量拉格朗日插值是将一维拉格朗日插值方法扩展到二维的情况。假设我们有一个图像，其已知的像素值为$P_{ij}$，其中$i, j = 0, 1, \ldots, n$，分别对应于$(x_i, y_j)$位置。我们需要在$(x, y)$位置上插值一个新的像素值$P$。

双变量拉格朗日插值的公式为：
$$
P = \sum_{i=0}^n \sum_{j=0}^n P_{ij} \cdot L_i(x) \cdot L_j(y)
$$
其中$L_i(x)$和$L_j(y)$是一维拉格朗日基函数，定义为：
$$
L_i(x) = \prod_{\substack{0 \leq k \leq n \\ k \neq i}} \frac{x - x_k}{x_i - x_k}
$$

$$
L_j(y) = \prod_{\substack{0 \leq k \leq n \\ k \neq j}} \frac{y - y_k}{y_j - y_k}
$$

#### 双变量样条插值

双变量样条插值是将一维样条插值方法扩展到二维的情况。假设我们有一个图像，其已知的像素值为$P_{ij}$，其中$i, j = 0, 1, \ldots, n$，分别对应于$(x_i, y_j)$位置。我们需要在$(x, y)$位置上插值一个新的像素值$P$。

双变量样条插值的公式为：
$$
P = \sum_{i=0}^n \sum_{j=0}^n P_{ij} \cdot B_i(x) \cdot B_j(y)
$$
其中$B_i(x)$和$B_j(y)$是样条基函数，可以是三次样条、Catmull-Rom样条等。

#### 2.2.1在超分辨率的应用

使用插值法超分辨率的一个关键步骤是抗锯齿处理。例如下图中，左图是分辨率为$$3\times 3$$的斜线，右图是补全到$$6\times 6$$的图片。其中我们可以明显注意到，除了将像素翻倍显示，图片边缘处需要添加先前不存在的像素来保证边缘平滑。于是我们得到图像超分辨率的以下步骤：

1. 将原始图像分辨率翻倍
2. 使用双线性插值平滑边缘

![图2 超分辨率的示意图（灰色像素是超分辨率时额外补充的像素）](https://github.com/darrindeyoung791/NA_class_thesis/blob/master/res/img/Picture2.png?raw=true)

其中，双线性插值的基本思想是通过已知的四个像素值来计算目标像素的值。

假设目标像素位置为$$(x, y)$$，其周围的四个已知像素位置分别为 $$(x_0, y_0)$$、$$(x_0, y_1)$$、$$(x_1, y_0)$$ 和$$((x_1, y_1)$$，对应的像素值分别为 $$P_{00}$$、$$P_{01}$$、$$P_{10}$$ 和 $$P_{11}$$。双线性插值的公式为：
$$
P = P_{00} \cdot \frac{(x_1 - x)(y_1 - y)}{(x_1 - x_0)(y_1 - y_0)} + P_{01} \cdot \frac{(x_1 - x)(y - y_0)}{(x_1 - x_0)(y_1 - y_0)} + P_{10} \cdot \frac{(x - x_0)(y_1 - y)}{(x_1 - x_0)(y_1 - y_0)} + P_{11} \cdot \frac{(x - x_0)(y - y_0)}{(x_1 - x_0)(y_1 - y_0)}
$$



#### 2.2.2 在补全中间帧的应用

双变量插值是一种简单且有效的方法，适用于生成中间帧。假设我们有两帧图像 $$ F_1 $$ 和 $$ F_2 $$，我们需要生成一个中间帧 $$ F_{1.5} $$。

1. **双变量插值公式**：假设 $$ F_1 $$ 和 $$ F_2 $$ 的像素值分别为 $$ P_1(x,y) $$ 和 $$ P_2(x,y) $$，我们需要在位置 $$ (x,y) $$ 上生成中间帧 $$ F_{1.5} $$ 的像素值 $$ P_{1.5}(x,y) $$。可以使用线性插值公式：

    $$
    P_{1.5}(x,y) = \alpha \cdot P_1(x,y) + (1 - \alpha) \cdot P_2(x,y)
    $$

    其中，$$ \alpha $$ 是一个介于 0 和 1 之间的参数，表示中间帧在两帧之间的位置。对于中间帧 $$ F_{1.5} $$，可以取 $$ \alpha = 0.5 $$。

2. **实现**：通过遍历每一帧的每个像素位置，使用上述公式计算中间帧的像素值。这种方法简单且易于实现。

如果有多帧图像，可以使用多帧平均值的方法来生成中间帧。这种方法适用于多帧图像之间的变化较为平滑的场景。


1. **多帧平均公式**：假设我们有 $$ n $$ 帧图像 $$ F_1, F_2, \dots, F_n $$，我们需要生成一个中间帧 $$ F_{avg} $$。可以通过对这些帧的每个像素位置取平均值来实现：

    $$
    P_{avg}(x,y) = \frac{1}{n} \sum_{i=1}^{n} P_i(x,y)
    $$

    其中，$$ P_i(x,y) $$ 表示第 $$ i $$ 帧在位置 $$ (x,y) $$ 上的像素值。

2. **实现**：通过遍历每一帧的每个像素位置，计算这些像素值的平均值，从而得到中间帧的像素值。这种方法同样简单且易于实现。

![图3 插帧的示意图（中间图是依靠前后帧补全的画面）](https://github.com/darrindeyoung791/NA_class_thesis/blob/master/res/img/Picture3.png?raw=true)

## 3. 实验设计

### 3.1 性能测试思路

要测试两种算法的性能，我们可以考虑随机生成多张图片，然后计时比较两种算法的处理用时。对于超分辨率测试，生成50张$$16\times 16$$的图片，然后分别使用两种算法进行超分辨率并插值抗锯齿，输出$$32\times 32$$。对于插帧，生成51张$$32\times 32$$的图片，然后补全50张中间帧。

为了保证插帧的图片有意义，我们使用柏林噪声生成连续的随机图片。同样地，这个算法也被应用于超分辨率算法，可以保证控制台快速输出结果的情况下人眼能够通过连续性来简单判断算法是否有误。

### 3.2 程序代码设计

此处是伪代码。访问[**https://github.com/darrindeyoung791/NA_class_thesis**](https://github.com/darrindeyoung791/NA_class_thesis)可在`\src`目录下获取程序源码及其依赖。

#### 1. 超分辨率算法 (Super-resolution)

1.1 输入输出

```
Input: 
- image[n][n]: 原始图像 (n×n)
- scale_factor: 放大倍数

Output:
- upscaled_image[m][m]: 放大后图像 (m×m, m = n * scale_factor)
```

1.2 拉格朗日插值算法

```
Function lagrange_interpolation(image, x, y):
    1. 在x和y方向各选择4个最近的采样点
    2. 对每个方向:
        a. 计算拉格朗日基函数 L_i(t) = Π(t-t_j)/(t_i-t_j), j≠i
        b. 计算插值多项式 P(t) = Σy_i * L_i(t)
    3. 分别得到x方向和y方向的插值结果
    4. 返回两个方向插值的平均值

Function upscale_image_lagrange(image, scale_factor):
    1. 创建新图像 new_image[n*scale_factor][n*scale_factor]
    2. 对每个新像素位置 (x,y):
        a. 计算对应原图位置 (x/scale_factor, y/scale_factor)
        b. 调用 lagrange_interpolation 计算插值
    3. 返回放大后的图像
```

1.3 三次样条插值算法

```
Function cubic_spline_interpolation(image, x, y):
    1. 在x和y方向各选择4-5个局部点
    2. 对每个方向:
        a. 构建三次样条方程组 S_i(t) = a_i + b_i(t-t_i) + c_i(t-t_i)² + d_i(t-t_i)³
        b. 使用自然边界条件求解系数
        c. 计算插值点的值
    3. 返回两个方向插值的平均值

Function upscale_image_spline(image, scale_factor):
    1. 创建新图像 new_image[n*scale_factor][n*scale_factor]
    2. 对每个新像素位置 (x,y):
        a. 计算对应原图位置 (x/scale_factor, y/scale_factor)
        b. 调用 cubic_spline_interpolation 计算插值
    3. 返回放大后的图像
```

#### 2. 帧插值算法 (Frame Interpolation)

2.1 输入输出

```
Input:
- frame1[n][n], frame2[n][n]: 相邻两帧
- t: 插值时间点 (0≤t≤1)

Output:
- middle_frame[n][n]: 插值生成的中间帧
```

2.2 拉格朗日帧插值算法

```
Function interpolate_frames_lagrange(frame1, frame2, t):
    1. 对每个像素位置 (x,y):
        a. 构建时间维度上的4个控制点 [-1,0,1,2]
        b. 计算拉格朗日基函数
        c. 使用t进行时间维度插值
    2. 确保插值结果在[0,1]范围内
    3. 返回生成的中间帧
```

2.3 样条帧插值算法

```
Function interpolate_frames_spline(frame1, frame2, t):
    1. 定义时间维度控制点 [0, 1/3, 2/3, 1]
    2. 对每个像素位置 (x,y):
        a. 计算控制点对应的像素值:
           - v1 = frame1[y][x]
           - v2 = frame1[y][x] * 2/3 + frame2[y][x] * 1/3
           - v3 = frame1[y][x] * 1/3 + frame2[y][x] * 2/3
           - v4 = frame2[y][x]
        b. 构建三次样条并计算t时刻的值
    3. 确保插值结果在[0,1]范围内
    4. 返回生成的中间帧
```

### 3.3 实验结果

[等待补全]

## 4. 实验结果分析

[等待补全]

## 5. 结论

[等待补全]

## 6. 参考文献

[1] [游戏悍将]ASUS ENGTX295[J]. 个人电脑,2009,15(6):29.

[2] Haoshen Qin, Zixian Zhu. Investigating the Effect of Display Refresh Rate on First-Person Shooting Games[Z/OL]. (2024-06-18) [2025-05-25]. https://doi.org/10.48550/arXiv.2406.13027

[3] 老奇好好奇，搞机所. 我花了一个月，搞懂了这一帧[Z/OL]. (2025-01-07) [2025-05-24]. https://www.bilibili.com/video/BV1zsr5Y7Ecy

[4] 立航. 一篇文章搞懂柏林噪声算法，附代码讲解[Z/OL]. (2017-07-21) [2025-06-10]. https://www.cnblogs.com/leoin2012/p/7218033.html